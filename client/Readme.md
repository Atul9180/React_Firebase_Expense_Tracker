## RTK Query Approach:

#### break down the flow involving apiSlice, usersApiSlice, authSlice, and the Redux store:

1. In apiSlice: Generic API actions are defined.
   We created an API using createApi from @reduxjs/toolkit/query/react and will inject endpoints to it.

2. In usersApiSlice: User-specific API actions are defined.
   we inject additional endpoints related to user authentication and profile management using apiSlice.injectEndpoints. This extends the capabilities provided by apiSlice for user-specific actions.

3. In authSlice: manages the state.
   We create a slice for managing authentication-related state, including actions for setting user credentials and logging out.

4. In the Redux store configuration, we combine reducers from authSlice, apiSlice, and usersApiSlice.
   The default middleware includes the middleware provided by apiSlice, which handles the asynchronous actions generated by API calls. It manages the state transitions (pending, fulfilled, rejected) automatically.

We can use loading status from mutation/query actions: eg: const [login, { isLoading }] = useLoginMutation();

## Flow Summary:

##### 1. Action Creation:

Actions for user-related API calls (login, logout, signup, etc.) are created using usersApiSlice.
Actions for generic API calls (e.g., getUsers) are created using apiSlice.

##### 2. Reducer Management:

Reducers for authentication state (authSlice) and generic API state (apiSlice) are combined in the Redux store.

##### 3. Middleware Setup:

Middleware provided by apiSlice is included to handle asynchronous API actions.

This setup allows to manage both generic API calls and user-specific API calls in a modular and organized way. The tagTypes in apiSlice help with caching, and the middleware handles the complexities of asynchronous API interactions.

###### Flow Example - Storing in Local Storage:

Let's say you have a Redux action named setCredentials that is dispatched when a user logs in.
The setCredentials action creator creates an action object with a type of 'SET_CREDENTIALS' and a payload containing the user information.
The reducer for the authentication state (authSlice) listens for 'SET_CREDENTIALS' actions.
When it receives this action, it updates the authentication state in the store with the new user information.
Additionally, it stores the user information in the browser's local storage using localStorage.setItem.
The React component can then access the updated authentication state from the Redux store to reflect the logged-in user.

### Differnce between RTK Query Approach & createAsyncThunk Approach

##### RTK Query Approach:

###### Pros:

1. Automated Lifecycle Handling: RTK Query automates the process of defining actions for API calls, handling loading, success, and error states automatically.

2. Reduced Boilerplate: It significantly reduces boilerplate code compared to manually defining each lifecycle step.

3. Normalized State: RTK Query encourages normalized state structures, simplifying data management.

###### Cons:

Less Customization: While it covers common use cases well, there might be scenarios where specific customization is needed, and RTK Query might be less flexible.

##### createAsyncThunk Approach:

###### Pros:

1. Fine-grained Control: This approach provides fine-grained control over each step of the asynchronous operation (pending, fulfilled, and rejected actions).

2. Custom Logic: Developers can implement custom logic for each lifecycle step, enabling complex scenarios and manual handling.

###### Cons:

1. Boilerplate Code: Handling each lifecycle step separately may result in more boilerplate code and potential repetition across different slices.

2. Complexity: Managing the complexity of multiple actions for each API call might become challenging as the application grows.
